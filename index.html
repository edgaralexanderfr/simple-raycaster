<canvas width="800" height="480"></canvas>
<script type="text/javascript">
	/**
	 * @return object
	 */
	function dda (sx, sy, dx, dy, testX, testY) {
		var testX      = (testX) ? Math.floor(testX) : -1 ;
		var testY      = (testY) ? Math.floor(testY) : -1 ;
		var test       = false;
		var mapX       = Math.floor(sx);
		var mapY       = Math.floor(sy);
		var deltaDistX = Math.sqrt(1 + (dy * dy) / (dx * dx));
		var deltaDistY = Math.sqrt(1 + (dx * dx) / (dy * dy));
		var stepX, stepY, sideDistX, sideDistY, side;

		if (dx < 0.0) {
			stepX     = -1;
			sideDistX = (sx - mapX) * deltaDistX;
		} else {
			stepX     = 1;
			sideDistX = (mapX + 1.0 - sx) * deltaDistX;
		}

		if (dy < 0.0) {
			stepY     = -1;
			sideDistY = (sy - mapY) * deltaDistY;
		} else {
			stepY     = 1;
			sideDistY = (mapY + 1.0 - sy) * deltaDistY;
		}

		while (true) {
			if (sideDistX < sideDistY) {
				sideDistX += deltaDistX;
				mapX      += stepX;
				side       = 0;
			} else {
				sideDistY += deltaDistY;
				mapY      += stepY;
				side       = 1;
			}

			if (map[ mapY ] != undefined && map[ mapY ][ mapX ] != undefined && map[ mapY ][ mapX ] > 0) {
				break;
			}

			if (mapX == testX && mapY == testY) {
				test = true;

				break;
			}
		}
			
		var distance = (side == 0) ? (mapX - sx + (1 - stepX) / 2) / dx : (mapY - sy + (1 - stepY) / 2) / dy ;
		var hitX = sx + (distance * dx);
		var hitY = sy + (distance * dy);

		return {
			mapX     : mapX, 
			mapY     : mapY, 
			side     : side, 
			distance : distance, 
			test     : test, 
			hitX     : hitX, 
			hitY     : hitY
		}
	}

	function render () {
		// Calculate deltaTime
		var currentFrameTime = Date.now();
		var deltaTime = (lastFrameTime == 0) ? 0.0 : (currentFrameTime - lastFrameTime) / 1000 ;
		lastFrameTime = currentFrameTime;

		// We interpolate camera view
		var oldPlaneX;
		
		if (movingUp) {
			x += Math.cos(a) * s * deltaTime;
			y += Math.sin(a) * s * deltaTime;
		}

		if (movingDown) {
			x += Math.cos(a + Math.PI) * s * deltaTime;
			y += Math.sin(a + Math.PI) * s * deltaTime;
		}

		if (lookingLeft) {
			a        -= ts * deltaTime;
			oldPlaneX = planeX;
			planeX    = planeX    * Math.cos(-ts * deltaTime) - planeY * Math.sin(-ts * deltaTime);
			planeY    = oldPlaneX * Math.sin(-ts * deltaTime) + planeY * Math.cos(-ts * deltaTime);
		}

		if (lookingRight) {
			a        += ts * deltaTime;
			oldPlaneX = planeX;
			planeX    = planeX    * Math.cos(ts * deltaTime) - planeY * Math.sin(ts * deltaTime);
			planeY    = oldPlaneX * Math.sin(ts * deltaTime) + planeY * Math.cos(ts * deltaTime);
		}

		// We begin raytracing
		var cs              = Math.round(canvas.width / Math.max(columns, 1));
		var c, cameraX, dx, dy, mapX, mapY, side, distance, height, tex, wallX, texX;
		context.globalAlpha = 1.0;
		context.fillStyle   = 'black';
		context.fillRect(0, 0, canvas.width, canvas.height);

		for (c = 0; c < canvas.width; c += cs) {
			cameraX  = 2 * c / canvas.width - 1;
			dx       = Math.cos(a) + planeX * cameraX;
			dy       = Math.sin(a) + planeY * cameraX;
			cast     = dda(x, y, dx, dy);
			mapX     = cast.mapX;
			mapY     = cast.mapY;
			side     = cast.side;
			distance = cast.distance;
			height   = Math.floor(wallsHeight * canvas.height / distance);
			tex      = textures[ map[ mapY ][ mapX ] - 1 ];
			wallX    = (side == 0) ? y + distance * dy : x + distance * dx ;
			wallX   -= Math.floor(wallX);
			texX     = Math.floor(wallX * tex.width);

			if ((side == 0 && dx > 0) || (side == 1 && dy < 0)) {
				texX = tex.width - texX - 1;
			}

			if (fadeDistance > 0.0) {
				context.globalAlpha = 1.0 - (Math.min(distance, fadeDistance) / fadeDistance);
			}

			context.drawImage(tex, Math.floor(texX), 0, cs, tex.height, c, Math.floor(z + (canvas.height - height) / 2), cs, height);
		}

		if (fps > 0) {
			setTimeout(render, 1000 / fps);
		} else {
			requestAnimationFrame(render);
		}
	}

	onkeydown = function (e) {
		switch (String.fromCharCode(e.which).toLowerCase()) {
			case 'w' : {
				movingUp = true;
			} ; break;
			case 's' : {
				movingDown = true;
			} ; break;
			case 'a' : {
				lookingLeft = true;
			} ; break;
			case 'd' : {
				lookingRight = true;
			}
		}
	}

	onkeyup = function (e) {
		switch (String.fromCharCode(e.which).toLowerCase()) {
			case 'w' : {
				movingUp = false;
			} ; break;
			case 's' : {
				movingDown = false;
			} ; break;
			case 'a' : {
				lookingLeft = false;
			} ; break;
			case 'd' : {
				lookingRight = false;
			} ; break;
			case 'i' : {
				z += zs;
			} ; break;
			case 'k' : {
				z -= zs;
			}
		}
	}

	var textures    = [];
	var wallsHeight = 1.5;
	var map         = [
		[1,1,1,1,1,1,1,1,1,1], 
		[1,0,0,0,0,0,0,0,0,1], 
		[1,0,1,1,0,0,1,1,0,1], 
		[1,0,1,1,0,0,1,1,0,1], 
		[1,0,0,0,0,0,0,0,0,1], 
		[1,0,0,0,0,0,0,0,0,1], 
		[1,0,1,1,0,0,1,1,0,1], 
		[1,0,1,1,0,0,1,1,0,1], 
		[1,0,0,0,0,0,0,0,0,1], 
		[1,1,1,1,1,1,1,1,1,1], 
	];
	var canvas        = document.querySelector('canvas');
	var context       = canvas.getContext('2d');
	var fps           = 0;
	var x             = 5.0;
	var y             = 5.0;
	var z             = 0.0;
	var a             = 0.0;
	var planeX        = 0.0;
	var planeY        = 0.66;
	var columns       = Math.round(canvas.width / 1);
	var fadeDistance  = 4.0;
	var s             = 2;
	var zs            = 50;
	var ts            = 2;
	var lastFrameTime = 0;
	var movingUp      = false;
	var movingDown    = false;
	var lookingLeft   = false;
	var lookingRight  = false;
	var texture       = new Image;
	texture.src       = 'texture.png';
	textures.push(texture);
	render();
</script>