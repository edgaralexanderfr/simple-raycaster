<canvas width="800" height="480"></canvas>
<script type="text/javascript">
	function render () {
		// Calculate deltaTime
		var currentFrameTime = Date.now();
		var deltaTime = (lastFrameTime == 0) ? 0.0 : (currentFrameTime - lastFrameTime) / 1000 ;
		lastFrameTime = currentFrameTime;

		// We interpolate camera view
		var oldPlaneX;
		
		if (movingUp) {
			x += Math.cos(a) * s * deltaTime;
			y += Math.sin(a) * s * deltaTime;
		}

		if (movingDown) {
			x += Math.cos(a + Math.PI) * s * deltaTime;
			y += Math.sin(a + Math.PI) * s * deltaTime;
		}

		if (lookingLeft) {
			a        -= ts * deltaTime;
			oldPlaneX = planeX;
			planeX    = planeX    * Math.cos(-ts * deltaTime) - planeY * Math.sin(-ts * deltaTime);
			planeY    = oldPlaneX * Math.sin(-ts * deltaTime) + planeY * Math.cos(-ts * deltaTime);
		}

		if (lookingRight) {
			a        += ts * deltaTime;
			oldPlaneX = planeX;
			planeX    = planeX    * Math.cos(ts * deltaTime) - planeY * Math.sin(ts * deltaTime);
			planeY    = oldPlaneX * Math.sin(ts * deltaTime) + planeY * Math.cos(ts * deltaTime);
		}

		// We begin raytracing
		var cs              = Math.round(canvas.width / Math.max(columns, 1));
		var c, cameraX, dx, dy, mapX, mapY, deltaDistX, deltaDistY, stepX, stepY, sideDistX, sideDistY, side, distance, height, tex, wallX, texX;
		//context.globalAlpha = 1.0;
		//context.fillStyle   = 'black';
		//context.fillRect(0, 0, canvas.width, canvas.height);

		for (c = 0; c < canvas.width; c += cs) {
			cameraX    = 2 * c / canvas.width - 1;
			dx         = Math.cos(a) + planeX * cameraX;
			dy         = Math.sin(a) + planeY * cameraX;
			mapX       = Math.floor(x);
			mapY       = Math.floor(y);
			deltaDistX = Math.sqrt(1 + (dy * dy) / (dx * dx));
			deltaDistY = Math.sqrt(1 + (dx * dx) / (dy * dy));

			if (dx < 0.0) {
				stepX     = -1;
				sideDistX = (x - mapX) * deltaDistX;
			} else {
				stepX     = 1;
				sideDistX = (mapX + 1.0 - x) * deltaDistX;
			}

			if (dy < 0.0) {
				stepY     = -1;
				sideDistY = (y - mapY) * deltaDistY;
			} else {
				stepY     = 1;
				sideDistY = (mapY + 1.0 - y) * deltaDistY;
			}

			while (true) {
				if (sideDistX < sideDistY) {
					sideDistX += deltaDistX;
					mapX      += stepX;
					side       = 0;
				} else {
					sideDistY += deltaDistY;
					mapY      += stepY;
					side       = 1;
				}

				if (map[ mapY ] != undefined && map[ mapY ][ mapX ] != undefined && map[ mapY ][ mapX ] > 0) {
					break;
				}
			}
			
			distance = (side == 0) ? (mapX - x + (1 - stepX) / 2) / dx : (mapY - y + (1 - stepY) / 2) / dy ;
			height   = Math.floor(wallsHeight * canvas.height / distance);
			tex      = textures[ map[ mapY ][ mapX ] - 1 ];
			wallX    = (side == 0) ? y + distance * dy : x + distance * dx ;
			wallX   -= Math.floor(wallX);
			texX     = Math.floor(wallX * tex.width);

			if ((side == 0 && dx > 0) || (side == 1 && dy < 0)) {
				texX = tex.width - texX - 1;
			}

			if (fadeDistance > 0.0) {
				//context.globalAlpha = 1.0 - (Math.min(distance, fadeDistance) / fadeDistance);
			}

			//context.drawImage(tex, Math.floor(texX), 0, cs, tex.height, c, Math.floor(z + (canvas.height - height) / 2), cs, height);
			var drawStart = Math.floor(z + (canvas.height - height) / 2);
			var drawEnd = drawStart + height;
			var vy;
			var index;

			for (vy = drawStart; vy < drawEnd; vy++) {
				index = (vy * canvasWidth + c) * 4;
				buffer[ index ]     = 255;
				buffer[ index + 1 ] = 0;
				buffer[ index + 2 ] = 255;
				buffer[ index + 3 ] = 255;
			}

			var floorXWall, floorYWall;

			if (side == 0 && dx > 0) {
				floorXWall = mapX;
				floorYWall = mapY + wallX;
			} else 
			if (side == 0 && dx < 0) {
				floorXWall = mapX + 1.0;
				floorYWall = mapY + wallX;
			} else 
			if (side == 1 && dy > 0) {
				floorXWall = mapX + wallX;
				floorYWall = mapY;
			} else {
				floorXWall = mapX + wallX;
				floorYWall = mapY + 1.0;
			}

			var h = canvas.height;
			var distWall, distPlayer, currentDist;

			distWall = distance;
			distPlayer = 0.0;

			for (vy = drawEnd + 1; vy < h; vy++) {
				currentDist = h / (2.0 * vy - h);

				var weight = (currentDist - distPlayer) / (distWall - distPlayer);

				var currentFloorX = weight * floorXWall + (1.0 - weight) * x;
				var currentFloorY = weight * floorYWall + (1.0 - weight) * y;

				var floorTexX, floorTexY;
				floorTexX = Math.floor(currentFloorX * texWidth) % texWidth;
				floorTexY = Math.floor(currentFloorY * texHeight) % texHeight;

				// floor
				index = (vy * canvasWidth + c) * 4;
				buffer[ index ]     = 0;
				buffer[ index + 1 ] = 255;
				buffer[ index + 2 ] = 0;
				buffer[ index + 3 ] = 255;

				// ceiling
				index = ((h - vy) * canvasWidth + c) * 4;
				buffer[ index ]     = 0;
				buffer[ index + 1 ] = 0;
				buffer[ index + 2 ] = 255;
				buffer[ index + 3 ] = 255;
			}
		}

		context.putImageData(data, 0, 0);

		if (fps > 0) {
			setTimeout(render, 1000 / fps);
		} else {
			requestAnimationFrame(render);
		}
	}

	onkeydown = function (e) {
		switch (String.fromCharCode(e.which).toLowerCase()) {
			case 'w' : {
				movingUp = true;
			} ; break;
			case 's' : {
				movingDown = true;
			} ; break;
			case 'a' : {
				lookingLeft = true;
			} ; break;
			case 'd' : {
				lookingRight = true;
			}
		}
	}

	onkeyup = function (e) {
		switch (String.fromCharCode(e.which).toLowerCase()) {
			case 'w' : {
				movingUp = false;
			} ; break;
			case 's' : {
				movingDown = false;
			} ; break;
			case 'a' : {
				lookingLeft = false;
			} ; break;
			case 'd' : {
				lookingRight = false;
			} ; break;
			case 'i' : {
				z += zs;
			} ; break;
			case 'k' : {
				z -= zs;
			}
		}
	}

	var textures    = [];
	var wallsHeight = 1.5;
	var map         = [
		[1,1,1,1,1,1,1,1,1,1], 
		[1,0,0,0,0,0,0,0,0,1], 
		[1,0,1,1,0,0,1,1,0,1], 
		[1,0,1,1,0,0,1,1,0,1], 
		[1,0,0,0,0,0,0,0,0,1], 
		[1,0,0,0,0,0,0,0,0,1], 
		[1,0,1,1,0,0,1,1,0,1], 
		[1,0,1,1,0,0,1,1,0,1], 
		[1,0,0,0,0,0,0,0,0,1], 
		[1,1,1,1,1,1,1,1,1,1], 
	];
	var canvas        = document.querySelector('canvas');
	var canvasWidth   = canvas.width;
	var canvasHeight  = canvas.height;
	var context       = canvas.getContext('2d');
	var fps           = 0;
	var x             = 5.0;
	var y             = 5.0;
	var z             = 0.0;
	var a             = 0.0;
	var planeX        = 0.0;
	var planeY        = 0.66;
	var columns       = Math.round(canvas.width / 1);
	var fadeDistance  = 4.0;
	var s             = 2;
	var zs            = 50;
	var ts            = 2;
	var lastFrameTime = 0;
	var movingUp      = false;
	var movingDown    = false;
	var lookingLeft   = false;
	var lookingRight  = false;
	var texture       = new Image;
	var data          = context.getImageData(0, 0, canvas.width, canvas.height);
	var buffer        = data.data;
	var texWidth, texHeight;
	
	texture.onload = function (e) {
		texWidth = texture.width;
		texHeight = texture.height;
		render();
	}

	texture.src       = 'texture.png';
	textures.push(texture);
</script>